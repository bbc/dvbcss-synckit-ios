//
//  WCMeasurementsCollector.m
//  WallClockClient
//
//  Created by Rajiv Ramdhany on 13/08/2014.
//  Copyright (c) 2014 BBC R&D. All rights reserved.
//
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

#import "WCSyncMessage.h"
#import "Candidate.h"
#import "WCProtocolClient.h"

#import <SyncKitConfiguration/SyncKitConfiguration.h>
#import <ClockTimelines/ClockTimelines.h>
#import <SimpleLogger/SimpleLogger.h>
#import <SyncKitCollections/NSStack.h>
#import <SyncKitCollections/utils.h>

#import <pthread.h>
#import <sys/types.h> // for timeval
#import <sys/time.h>


// max number of messages generated by this application per second
#define WCMSG_RATELIMIT	10
#define DEF_SEND_WCSYNC_REQ_PERIOD 500000 // in microsecs

/** TODO:
 1. ratelimit emission of WC Sync Messages --> DONE
 2. write testcases for unit testing --> DONE
 3. handle follow-up messages from WCServer -->DONE
*/

@interface WCProtocolClient()
{
   
    
    
}

/**
 *  A UDP socket endpoint for protocol message exchange
 */
@property (nonatomic, strong, readwrite) UDPEndpoint *udp_endpoint;

/**
 *  Config reader
 */
@property (nonatomic, weak) SyncKitGlobals* config;


#pragma mark private methods
///-----------------------------------------------------------
/// @name private methods
///-----------------------------------------------------------

/**
 *  Thread function for sending WC request messages
 */
- (void) requestSenderThreadFunc;

/**
 *  A thread to check for incoming messages at the UDP endpoint
 */
- (void) MsgHandlerThreadFunc;


/**
 *  Creates a UDPComms object for sending andf receiving messages and schedules the non-blocking socket for receiving
 *
 *  @param host - hostname or address
 *  @param port - port number
 *
 *  @return true if endpoint was created and started
 */
- (BOOL)runClientWithHost:(NSString *)host port:(NSUInteger)port;


/**
 *  Look up in message cache and return a matching message for the reply
 *
 *  @param reply - a WC reponse message fom a WC server
 *
 *  @return corresponding request message for response message
 */
- (WCSyncMessage *) WCSyncMsgCacheLookUp: (WCSyncMessage *) reply;

@end

@implementation WCProtocolClient
{
    // msg cache
    NSMutableArray          *wcSyncMessageCache;
    
    // threads and mutexes
    NSThread                *requestSenderThread;       // send request thread
    NSThread                *recvPollThread;
    pthread_mutex_t         WCMsgCacheMutex;            // mutex to avoid race conditions on wcSyncReqHistory by
    pthread_mutex_t         mutex;                      // mutex for ready_to_go condition var
    pthread_cond_t          condition;
    Boolean                 ready_to_go;                // condition variable
    Boolean                 continue_loop;             // continue thread loop flag
    
    /* Used to limit rate of sending messages */
    struct timeval          wcMsgRateArray[WCMSG_RATELIMIT];
    int                     num_req_msgs;
    
    // clean up stale messages
    NSStack                 *removables;
    
}

@synthesize udp_endpoint = _udp_endpoint;
@synthesize config = _config;


#pragma mark Initialisation routines
///-----------------------------------------------------------
/// @name Initialiser methods
///-----------------------------------------------------------
/** init with defaults */
- (id)init
{
    self = [super init];
    if (self != nil) {
        
        // get a reference to object containing device constants
        _config = [SyncKitGlobals getInstance];
        
        //set up wall clock request target and frequency
        _hostName = @"localhost";
        _port = 7777;
        
         num_req_msgs = 0;
        
        // instantiate a SystemClock object (default) and use it in this WCMeasurementsCollector instance
         
        _wallclockRef = [[SystemClock alloc] initWithTickRate:_kOneThousandMillion];
        assert(_wallclockRef!=nil);
        
        // thread control flags
        ready_to_go = false;
        continue_loop = true;
        
        wcSyncMessageCache = [[NSMutableArray alloc] initWithCapacity:5];
        pthread_mutex_init(&WCMsgCacheMutex, NULL);
        removables = [[NSStack alloc] init];
        
        pthread_mutex_init(&mutex, NULL);
        
        pthread_cond_init(&condition, NULL);
        
        // create our send request thread, thread started after UDP endpoint has been set up
        requestSenderThread =   [[NSThread alloc]
                                 initWithTarget:self
                                 selector:@selector(requestSenderThreadFunc)
                                 object:nil];
        
       
        
        // create our receive thread, thread started after UDP endpoint has been set up
        recvPollThread =   [[NSThread alloc]
                            initWithTarget:self
                            selector:@selector(MsgHandlerThreadFunc)
                            object:nil];
        
        // start the UDP comms component in client mode
        [self runClientWithHost:_hostName port:_port];
        
    }
    return self;
}


- (id) initWithHost:(NSString*) hostname Port:(NSUInteger) port AndWallClock:(ClockBase*) clock
{
    self = [super init];
    
    
    if (self != nil) {
        
        // get ConfigReader singleton
        // get a reference to object containing device constants
        _config = [SyncKitGlobals getInstance];
        
        //set up wall clock requests target and frequency
        _hostName = hostname;
        _port = port;
        
        // use supplied clock
        _wallclockRef = clock;
        
        // thread control flags
        ready_to_go = false;
        continue_loop = true;
        
        // init Request mesg list
        wcSyncMessageCache = [[NSMutableArray alloc] initWithCapacity:5];
         pthread_mutex_init(&WCMsgCacheMutex, NULL);
        
        removables = [[NSStack alloc] init];
        
        pthread_mutex_init(&mutex, NULL);
        pthread_cond_init(&condition, NULL);
        
        // create our send request thread, thread started after UDP endpoint has been set up
        requestSenderThread =   [[NSThread alloc]
                                 initWithTarget:self
                                 selector:@selector(requestSenderThreadFunc)
                                 object:nil];
        
        
        
        // create our receive thread, thread started after UDP endpoint has been set up
        recvPollThread =   [[NSThread alloc]
                            initWithTarget:self
                            selector:@selector(MsgHandlerThreadFunc)
                            object:nil];
        
        num_req_msgs = 0;
        
        // start the UDP comms component in client mode
        [self runClientWithHost:_hostName port:_port];
    }
    return self;
    
}

/**
 Initialise the measurement collector
 */
- (id) initWithHost:(NSString*) hostname Port:(NSUInteger) port CandidateSink:(id<ICandidateHandler>) can_sink AndWallClock:(ClockBase*) clock
{
    self = [super init];
    
    
    if (self != nil) {
        
        // get ConfigReader singleton
        // get a reference to object containing device constants
        _config = [SyncKitGlobals getInstance];
        
        //set up wall clock requests target and frequency
        _hostName = hostname;
        _port = port;
        
        // use supplied clock
        _wallclockRef = clock;
        
        //candidate sink
        _candidateSink = can_sink;
        
        // thread control flags
        ready_to_go = false;
        continue_loop = true;
        
        // init Request mesg list
        wcSyncMessageCache = [[NSMutableArray alloc] initWithCapacity:5];
        pthread_mutex_init(&WCMsgCacheMutex, NULL);
        
        removables = [[NSStack alloc] init];
        
        pthread_mutex_init(&mutex, NULL);
        pthread_cond_init(&condition, NULL);
        
        
        num_req_msgs = 0;
        
        
    }
    return self;
    
}



/**
 Clean up code when instance is destroyed
 */

- (void) dealloc{
    // stop the thread
    
    
    self.hostName = nil;
    self.hostAddress =  nil;
    self.port = 0;
    self.candidateSink = nil;
    continue_loop = false;
    
    _config = nil;
    
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&condition);
    
    [_udp_endpoint stop];
    _udp_endpoint = nil; // leave to be garbage collected
}




#pragma mark UDPCommsDelegate methods
///-----------------------------------------------------------
/// @name UDPCommsDelegate methods
///-----------------------------------------------------------
/**
 This UDPComms delegate method is called after successfully receiving data.
*/
- (void) didReceiveData:(NSData *)data fromAddress:(NSData *)addr
{
    NSUInteger          dataLength;
    WCSyncMessagePkt    *wcRespPkt;
    WCSyncMessage       *wcResponseMsg;
    WCSyncMessage       *cachedMsg=nil;
    Candidate*          candidate;
    uint64_t            now;
    int                 quality = 0; // response quality
    
    assert(data != nil);
    assert(addr != nil);
    //NSLog(@"received packet  from %@ ... ", DisplayAddressForAddress(addr));
    
    
    // get packet bytes
    dataLength = [data length];
    wcRespPkt = (WCSyncMessagePkt*) [data bytes];
    assert(wcRespPkt != nil);
    
    // get timestamp for response time value as early as possible
    now = [_wallclockRef nanoSeconds];
    
    // build the response message, packet is deep-copied
    //MWLogDebug(@"WCClientProtocolImpl: reponse packet creation from receive buffer");
    wcResponseMsg = [[WCSyncMessage alloc] initWithPacket:wcRespPkt AndResponseTimeNanos:now];
    
    cachedMsg = [self WCSyncMsgCacheLookUp:wcResponseMsg];
    
    if (cachedMsg){
        quality = 0;
        free(cachedMsg.packet);
        cachedMsg = nil;
    }
    else
        quality = -10;
    
    switch (wcRespPkt->message_type) {
        
        case WCMSG_RESP:
            // Response message received
            quality +=3;
            break;
 
        case WCMSG_RESP_WITH_FOLLOWUP:
            // response message to-be-followed-up-by-another-response-msg received
            // should not result in a candidate measurement unless follow-up is not received within timeout
            quality +=2;
            
            // cache this message 
            [wcSyncMessageCache addObject:wcResponseMsg];
            break;
            
        case WCMSG_FOLLOWUP:
            // follow up message received
            quality +=4;
            break;
            
        default:
            // do nothing, message dropped.
            break;
    }
    
    if (quality >=3)
    {
        candidate = [[Candidate alloc] initWithResponseMsg:wcResponseMsg Quality:quality TimeIsNanos:true];
       // MWLogDebug(@"WCProtocolClient.didReceiveData: %@", [wcResponseMsg description]);
        
        if (_candidateSink !=nil)
            [_candidateSink enqueueCandidate:candidate];
    }
    
    
    
}


- (void) didReceiveError:(NSError *)error
// This UDPComms delegate method is called after a failure to receive data.
{
    assert(error != nil);
    MWLogDebug(@"WallClockProtocolClient: received error: %@", DisplayErrorFromError(error));
}



- (void) didSendData:(NSData *)data toAddress:(NSData *)addr
// This UDPComms delegate method is called after successfully sending data.
{
//    assert(data != nil);
//    assert(addr != nil);
//    NSLog(@"sent %@ to   %@", DisplayHexStringFromData(data), DisplayAddressForAddress(addr));
}

- (void) didFailToSendData:(NSData *)data toAddress:(NSData *)addr error:(NSError *)error
// This UDPComms delegate method is called after a failure to send data.
{
    assert(data != nil);
    assert(addr != nil);
    assert(error != nil);
    MWLogError(@"WallClockProtocolClient: error sending %@ to   %@, error: %@", DisplayStringFromData(data), DisplayAddressForAddress(addr), DisplayErrorFromError(error));
}

- (void) didStartWithAddress:(NSData *)address
// This UDPComms delegate method is called after the object has successfully started up.
{
    assert(address != nil);
    
    if (self.udp_endpoint.isServer) {
        MWLogInfo(@"WallClockProtocolClient: receiving on %@", DisplayAddressForAddress(address));
    } else {
        MWLogInfo(@"WallClockProtocolClient: UDP endpoint connected to %@", DisplayAddressForAddress(address));
    }
    
    // unblock the send request thread to start sending WC Sync requests
//    if ( ! self.udp_endpoint.isServer ) {
//        [self start];
//    }
    
    // start the thread, it will block on the condition var ready_to_go
    [requestSenderThread start];
    // start the thread
    [recvPollThread start];
}

- (void) didStopWithError:(NSError *)error
// This UDPComms delegate method is called  after the object stops spontaneously.
{
    
    assert(error != nil);
    MWLogError(@"WallClockProtocolClient: failed with error: %@", DisplayErrorFromError(error));
    self.udp_endpoint = nil;
}



#pragma mark Component Control
///-----------------------------------------------------------
/// @name Component Control methods
///-----------------------------------------------------------

- (void) start{
    continue_loop= true;
    // create our send request thread, thread started after UDP endpoint has been set up
    requestSenderThread =   [[NSThread alloc]
                             initWithTarget:self
                             selector:@selector(requestSenderThreadFunc)
                             object:nil];
    
    
    
    // create our receive thread, thread started after UDP endpoint has been set up
    recvPollThread =   [[NSThread alloc]
                        initWithTarget:self
                        selector:@selector(MsgHandlerThreadFunc)
                        object:nil];

    
    
    _running = true;
    // start the UDP comms component in client mode
    [self runClientWithHost:_hostName port:_port];
    
    
    
    pthread_mutex_lock(&mutex);
    ready_to_go = true;
    
    // Signal the other thread to begin work.
    pthread_cond_signal(&condition);
    
    pthread_mutex_unlock(&mutex);
}

//
//- (void) pause{
//    _running = false;
//    pthread_mutex_lock(&mutex);
//    ready_to_go = !ready_to_go;
//    
//    // Signal the other thread to begin work.
//    pthread_cond_signal(&condition);
//    
//    pthread_mutex_unlock(&mutex);
//}


- (void) stop{
    continue_loop = false;
    [wcSyncMessageCache removeAllObjects];
    
   // udpendpoint object is stopped after thread loop exits
    
//    do{
//        wcmsg = [removables popObject];
//        if (wcmsg!=nil)
//        {
//            //MWLogDebug(@"emptying removables");
//            //[wcSyncMessageCache removeObject:wcmsg];
//            // free our malloc'ed memory chunk
//            free(wcmsg.packet);
//        }
//    }while (wcmsg !=nil);
    
}



#pragma mark private methods
///-----------------------------------------------------------
/// @name private methods
///-----------------------------------------------------------
/**
 Private method
 Creates a UDPComms object for sending andf receiving messages
 and schedules the non-blocking socket for receiving
 */
- (BOOL)runClientWithHost:(NSString *)host port:(NSUInteger)port

{
    assert(host != nil);
    assert( (port > 0) && (port < 65536) );
    
    assert(self.udp_endpoint == nil);
    
    self.udp_endpoint = [[UDPEndpoint alloc] initWithBufferSize:WCSYNCMSG_SIZE];
    assert(self.udp_endpoint != nil);
    
    self.udp_endpoint.delegate = self;
    
    [self.udp_endpoint startConnectedToHostName:host port:port];
    
    
    
    
    //    while (self.udp_endpoint != nil) {
    //        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    //    }
    
    // The loop above is supposed to run forever.  If it doesn't, something must
    // have failed and we want main to return EXIT_FAILURE.
    
    return YES;
}


/**
 Look up and return a matching message for the reply
 */
- (WCSyncMessage *) WCSyncMsgCacheLookUp: (WCSyncMessage *) reply
{
    WCSyncMessage* temp = nil;
    BOOL expired = false;
    BOOL match = false;
    uint64_t OriginateTimeNanos = 0;
    uint64_t now= 0;
    uint8_t lookuptype;
    uint64_t timeout = 0; // in nanos
    
    // define lookup type i.e. type of msg we are looking for in the message cache
    if ([reply getMessageType] == WCMSG_RESP)
    {
        // if we get a response, we do a lookup for the corresponding request in the cache
        lookuptype = WCMSG_REQ;
        timeout = ((uint64_t) [_config CachedWCREQTimeOutUSecs]) * 1000;
    }
    else if ([reply getMessageType] == WCMSG_RESP_WITH_FOLLOWUP)
    {
        lookuptype = WCMSG_REQ;
        timeout = ((uint64_t) [_config CachedWCREQTimeOutUSecs])* 1000;
    }
    else if ([reply getMessageType] == WCMSG_FOLLOWUP)
    {
        lookuptype = WCMSG_RESP_WITH_FOLLOWUP;
        timeout = ((uint64_t) [_config CachedWCRESPTimeOutUSecs]) * 1000;
    }else{
        MWLogError(@"WallClockProtocolClient: invalid msg lookup, received type = %u", [reply getMessageType]);
        return nil;
    }
    
    // get the lock on the message cache
    pthread_mutex_lock(&WCMsgCacheMutex);
    
    now = [_wallclockRef nanoSeconds];
    
    // look up in cache for match
    for (WCSyncMessage * cached_msg in wcSyncMessageCache) {
        OriginateTimeNanos = [cached_msg getOriginateTimeNanos];
        match = ( OriginateTimeNanos == [reply getOriginateTimeNanos]) && ([cached_msg getMessageType] == lookuptype);
        expired = now > (OriginateTimeNanos + timeout);
        
        if (match && !expired)
        {
            temp = cached_msg;
            break;
        }
    }
    
    if (temp !=nil){
        // MWLogDebug(@"WCClientProtocolImpl: Cache hit: %d", temp.hash);
        [wcSyncMessageCache removeObject:temp];
    }
    
    // release the lock
    pthread_mutex_unlock(&WCMsgCacheMutex);
    
    return temp;
}


/**
 
 Build and send a WC Synchronisation Request packet
 / we'll send the request then seek the best quality response
 //until timeout, or terminating early if we get a quality > 2
 //response (meaning that it was a non-followed-up response or a
 //follow-up response). A lower quality response is one where
 //a follow-up is expected or if it related to a previous request
 
 the request is saved to a list by the current thread and retrieved by the receiving
 thread upon the arrival for a corresponding response. Request is removed after arrival
 of a response or follow up, or it is removed after timeout
 
 */
- (void) sendWCSyncRequestPacket

{
    NSData *    data;
    WCSyncMessage* wcmsg;
    struct timeval now;
    
    assert(self.udp_endpoint != nil);
    assert( ! self.udp_endpoint.isServer );
    
    
    // Rate limit stuff
    gettimeofday(&now, NULL);
    
    if (num_req_msgs == WCMSG_RATELIMIT - 1)
    {
        if (timevaldiff(&now, &wcMsgRateArray[0]) < 1000)
        {
            //MWLogDebug(@"dropping packet");
            return;	// dropping packet
        }
        else
        {
            memmove(wcMsgRateArray,
                    &wcMsgRateArray[1],
                    sizeof(struct timeval) * (num_req_msgs - 1));
            wcMsgRateArray[num_req_msgs-1] = now;
        }
    }
    else
    {
        wcMsgRateArray[num_req_msgs] = now;
        num_req_msgs++;
    }
    
    
    // build packet using buffer in UDPComms component
    wcmsg = [[WCSyncMessage alloc] initWithBuffer:[self.udp_endpoint getSendBuffer]];
    
    [[[[[wcmsg setVersion:0] setMessageType:WCMSG_REQ] setPrecision:0] setReserved:0] setMaxFreqError:0];
    
    // Originate (T1) timestamp
    [wcmsg setOriginateTimeValue:[_wallclockRef nanoSeconds]];
    // MWLogDebug(@"WCReq.originatetime=%llu", [wcmsg getOriginateTimeNanos]);
    
    // make an NSData object out of the bytes, no mem copy
    data = [NSData dataWithBytesNoCopy:[self.udp_endpoint getSendBuffer] length:sizeof(WCSyncMessagePkt) freeWhenDone:NO];
    assert(data != nil);
    
    // clone the packet and store in cache
    wcmsg = [[WCSyncMessage alloc] initWithPacket:(WCSyncMessagePkt *)[self.udp_endpoint getSendBuffer]  AndResponseTimeNanos:0];
    
    // send
    [self.udp_endpoint sendData:data];
    
    
    // save request msg to list, after getting the lock
    pthread_mutex_lock(&WCMsgCacheMutex);
    [wcSyncMessageCache addObject:wcmsg];
    
    pthread_mutex_unlock(&WCMsgCacheMutex);
    
    }

/**
 remove stale request and response messages from message cache.
 */
- (void) refreshWCSyncMsgCache
{
    WCSyncMessage *wcmsg = nil;
    BOOL expired;
    uint64_t now = 0;
    Candidate* candidate;
    
    
    pthread_mutex_lock(&WCMsgCacheMutex);
    
    now = [_wallclockRef nanoSeconds];
    
    for (WCSyncMessage *wcmsg_temp in wcSyncMessageCache) {
        
        if ([wcmsg_temp getMessageType] == WCMSG_RESP_WITH_FOLLOWUP)
        {
            expired = now > ([wcmsg_temp getOriginateTimeNanos] + ([_config CachedWCRESPTimeOutUSecs] * 1000));
             if (expired)
             {
                 // This is the only response we have from the TV device so far since
                 // the follow up response was not received within the timeout period
                 // we therefore create a candidate object and enqueue it. The followup
                 // response will be discarded as the response has already expired.
                 MWLogDebug(@"WallClockProtocolClient: WCMSG_RESP_WITH_FOLLOWUP packet %d expired", wcmsg.hash);
                 candidate = [[Candidate alloc] initWithResponseMsg:wcmsg_temp Quality:2 TimeIsNanos:true];
                 if (_candidateSink!=nil)
                     [_candidateSink enqueueCandidate:candidate];
                 [removables pushObject:wcmsg_temp];
             }
        }else if ([wcmsg_temp getMessageType] == WCMSG_REQ)
        {
            
            // do nothing, just drop request
            expired = now > ([wcmsg_temp getOriginateTimeNanos] + ([_config CachedWCREQTimeOutUSecs] * 1000));
            if (expired)
                [removables pushObject:wcmsg_temp];
        }
        
    }
    
    // 
    do{
        wcmsg = [removables popObject];
        if (wcmsg!=nil)
        {
            //MWLogDebug(@"WallClockProtocolClient: dropping stale wallclock protocol packet %d", wcmsg.hash);
            [wcSyncMessageCache removeObject:wcmsg];
            // free our malloc'ed memory chunk
            free(wcmsg.packet);
        }
    }while (wcmsg !=nil);
   
    pthread_mutex_unlock(&WCMsgCacheMutex);
}




/**
 Calculate the quality of a response
 */
- (int) calcResponseQuality:(WCSyncMessagePkt*) WCRESP UsingRequest:(WCSyncMessage*) WCREQ
{
    int quality = 0;
    
    if (WCREQ == nil)
        quality = -10;
    else
        quality = 0;
    
    
    if (WCRESP->message_type == WCMSG_RESP)
    {
        return quality + 3;
    }else if (WCRESP->message_type == WCMSG_RESP_WITH_FOLLOWUP)
    {
        return quality + 2;
    }else if (WCRESP->message_type == WCMSG_FOLLOWUP)
    {
        return quality + 4;
    }
    
    return quality;
}


#pragma mark Thread Functions
///-----------------------------------------------------------
/// @name Thread functions
///-----------------------------------------------------------

- (void) requestSenderThreadFunc
{
    uint32_t default_sleep_period = [_config WCREQSendPeriodUSecs] ;
    
    MWLogInfo(@"WallClockProtocolClient: requestSenderThread has started.");
    do{
        
        // Lock the mutex.
        pthread_mutex_lock(&mutex);
        
        // If the predicate is already set, then the while loop is bypassed;
        // otherwise, the thread sleeps until the predicate is set.
        while(ready_to_go == false)
        {
            pthread_cond_wait(&condition, &mutex);
        }
        
        // Do work. (The mutex should stay locked.)
        [self sendWCSyncRequestPacket];
        
        
        // Reset the predicate and release the mutex.
        if (!_running) ready_to_go = false;
        
        pthread_mutex_unlock(&mutex);
        
        
        if (self.candidateSink != nil)
            usleep([self.candidateSink getNextRequestWaitTime]);
         else
             usleep(default_sleep_period);
        
    }while (continue_loop);
    
    MWLogInfo(@"WallClockProtocolClient: requestSenderThread has exited.");
}

- (void) MsgHandlerThreadFunc
{
     MWLogInfo(@"WallClockProtocolClient: MsgHandlerThread has started.");
    
    do{

       

        
        [_udp_endpoint checkForIncomingPackets:[_config SocketSelectTimeOutUSecs]];
        
        if (continue_loop) [self refreshWCSyncMsgCache];
        
        usleep(1000);
        
    }while(continue_loop);
    
     MWLogInfo(@"WallClockProtocolClient: MsgHandlerThread has exited.");
    
    [_udp_endpoint stop];
    
    _udp_endpoint = nil;
    
}





@end
